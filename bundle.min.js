function main(){function t(t,e){Object.keys(e).forEach((s=>{void 0!==e[s]&&(t[s]=e[s])}))}function e(t,e=!0){return e?console.log(t()):t()}function s(){return Math.floor(1e13*Math.random()).toString()}function i(t){const e={};return t.forEach((t=>e[t.id]=t)),e}class n{index=[];constructor(t){this.indexPrefix=t;const e=this.loadIndex();e?this.index=e:this.setIndex([])}get indexKey(){return`${this.indexPrefix}.index`}loadIndex(){const t=localStorage.getItem(this.indexKey);return t?JSON.parse(t):null}setIndex(t){localStorage.setItem(this.indexKey,JSON.stringify(t))}addToIndex(t){this.index.push(t),localStorage.setItem(this.indexKey,JSON.stringify(this.index))}addManyToIndex(t){this.index.push(...t),localStorage.setItem(this.indexKey,JSON.stringify(this.index))}removeFromIndex(t){const e=this.index.findIndex((e=>e===t));-1!==e&&(this.index.splice(e,1),localStorage.setItem(this.indexKey,JSON.stringify(this.index)))}getIdKey(t){return`${this.indexPrefix}.${t}`}findById(t){const e=localStorage.getItem(this.getIdKey(t));if(e)return{...JSON.parse(e),id:t}}findManyById(t){const e=[];return t.forEach((t=>{const s=this.findById(t);s&&e.push(s)})),e}getAll(){return this.index.map((t=>this.findById(t))).filter((t=>!!t))}createOne({id:t,...e}){localStorage.setItem(this.getIdKey(t),JSON.stringify(e)),this.addToIndex(t)}createMany(t){t.forEach((({id:t,...e})=>localStorage.setItem(this.getIdKey(t),JSON.stringify(e)))),this.addManyToIndex(t.map((({id:t})=>t)))}updateById(e,s){const i=this.findById(e);if(!i)throw new Error(`Could not update ${this.indexPrefix} record`);const n={...i};t(n,s),localStorage.setItem(this.getIdKey(e),JSON.stringify(n))}deleteById(t){localStorage.removeItem(this.getIdKey(t)),this.removeFromIndex(t)}deleteAll(){this.index.forEach((t=>localStorage.removeItem(this.getIdKey(t)))),this.index=[],this.setIndex([])}}class o extends n{static INDEX_PREFIX="testCase";constructor(){super(o.INDEX_PREFIX)}}class r extends n{static INDEX_PREFIX="execution";constructor(){super(r.INDEX_PREFIX)}}class a extends n{static INDEX_PREFIX="settings";constructor(){super(a.INDEX_PREFIX)}}class d{id="";env="";result=null;time=new Date;notes=null;constructor({execution:e,store:s}){t(this,e),this.store=s,this.dao=this.store.dao}get asCopyData(){return{env:this.env,result:this.result,timeInMs:this.time.getTime(),notes:this.notes}}get asCopy(){return{...this.asCopyData,id:this.id}}get info(){return`${this.env.toUpperCase()} (${this.result||"not run"})`+(this.notes?`: ${this.notes}`:"")}update(e){t(this,e),this.dao.updateById(this.id,this.asCopyData)}setNotes(t){this.update({notes:t})}pass(t,e=new Date){this.update({notes:t,time:e,result:"passed"})}fail(t,e=new Date){this.update({notes:t,time:e,result:"failed"})}block(t,e=new Date){this.update({notes:t,time:e,result:"blocked"})}uncheck(){this.update({result:null})}}class l{constructor({dao:t,rootStore:e}){this.dao=t,this.rootStore=e}get defaultEnv(){return this.rootStore.settings.env}autoCreate({result:t=null,time:e=new Date,notes:i=null}){return this.create({id:s(),result:t,time:e,notes:i,env:this.defaultEnv})}create(t){const e=this.genExecution(t);return this.dao.createOne(e.asCopy),e}createMany(t){const e=t.map((t=>this.genExecution(t)));return this.dao.createMany(e.map((({asCopy:t})=>t))),console.log(`${e.length} executions added`),e}import(t){const e=t.map((t=>this.genExecution(u(t))));return this.dao.createMany(t),console.log(`${e.length} executions added`),e}getOneById(t){const e=this.dao.findById(t);if(e)return this.genExecution(u(e))}getManyById(t){return this.dao.findManyById(t).map((t=>this.genExecution(u(t))))}genExecution(t){return new d({execution:t,store:this})}}function u({timeInMs:t,...e}){return{...e,time:new Date(t)}}class h{id="";executions={};constructor({testCase:e,store:s}){t(this,e),this.store=s,this.dao=this.store.dao}get executed(){return!!this.executionList.length}get asCopyData(){const t={};return Object.entries(this.executions).forEach((([e,{id:s}])=>t[e]=s)),{executionIds:t}}get asCopy(){return{...this.asCopyData,id:this.id}}get executionList(){return Object.values(this.executions)}get info(){if(!this.executed)return`${this.id} (not run)`;const t=this.executionList;return 1===t.length?`${this.id} - ${t[0].info}`:`${this.id}\n\t- ${t.map((t=>t.info)).join("\n\t- ")}`}get variableName(){return this.id.toLowerCase().replace("-","")}get defaultEnv(){return this.store.rootStore.settings.env}get executionStore(){return this.store.rootStore.executionStore}getExecution(t){if(this.executions[t])return this.executions[t]}setResult(t,e,s){const i=this.getExecution(this.defaultEnv),n=i||this.executionStore.autoCreate({result:t,time:s,notes:e});n.update({result:t,notes:e,time:s}),i||(this.executions[this.defaultEnv]=n,this.dao.updateById(this.id,this.asCopyData))}pass(t,e){this.setResult("passed",t,e)}fail(t,e){this.setResult("failed",t,e)}block(t,e){this.setResult("blocked",t,e)}uncheck(){this.setResult(null,null)}}class c{testCases=[];constructor({dao:t,rootStore:e}){this.dao=t,this.rootStore=e,this.init()}init(){this.loadTestCases()}loadTestCases(){const t=this.dao.getAll(),e=i(this.rootStore.executionStore.getManyById(t.flatMap((({executionIds:t})=>Object.values(t)))));this.testCases=t.map((({id:t,executionIds:s})=>{const i={};return Object.entries(s).forEach((([t,s])=>{const n=e[s];n&&(i[t]=n)})),this.genTestCase({id:t,executions:i})}))}create(t){const e=this.genTestCase(t);return this.testCases.push(e),this.dao.createOne(e.asCopy),e}createMany(t){const e=t.map((t=>this.genTestCase(t)));return this.testCases.push(...e),this.dao.createMany(e.map((({asCopy:t})=>t))),console.log(`${e.length} test cases added`),e}import(t){const e=t.flatMap((({executionCopies:t})=>Object.values(t))),s=i(this.rootStore.executionStore.import(e));this.testCases=t.map((({id:t,executionCopies:e})=>{const i=Object.values(e).map((({id:t})=>t)),n={};return Object.entries(i).forEach((([t,e])=>{const i=s[e];i&&(n[t]=i)})),this.genTestCase({id:t,executions:n})})),console.log(`${t.length} test cases added`)}getAllExecuted(){return this.testCases.filter((({executed:t})=>t))}getAllNotRun(){return this.testCases.filter((({executed:t})=>!t))}genTestCase(t){return new h({testCase:t,store:this})}getAllByResult(t,e){return t?this.getAllExecuted().filter((({executions:s})=>!!Object.entries(s).find((([s,i])=>(!e||e===s)&&i?.result===t)))):this.getAllNotRun()}getRandomNotRun(){const t=this.getAllNotRun(),e=t.length;if(!e)return;return t[Math.floor(e*Math.random())]}getOneById(t){return this.testCases.find((({id:e})=>e===t))}getReport(t){const e=this.getAllExecuted(),s=this.getAllByResult("failed",t),i=this.getAllByResult("blocked",t),n=this.getAllByResult("passed",t),o=s.length?`\n\nFailed:\n${this.makeList(s)}`:"",r=i.length?`\n\nBlocked:\n${this.makeList(i)}`:"",a=n.length?`\n\nPassed:\n${this.makeList(n)}`:"";return`${t.toUpperCase()} - Test cases run: ${e.length}\n\tpassed: ${n.length}; failed: ${s.length}; blocked: ${i.length}`+o+r+a}list(t){return(t?this.testCases.slice(0,t):this.testCases).map((t=>`- [${t.executed?"x":" "}] `+t.info)).join("\n")}listExecuted(){return this.makeList(this.getAllExecuted())}listNotRun(){return this.makeList(this.getAllNotRun())}listByResult(t){return this.makeList(this.getAllByResult(t))}makeList(t){return t.map((t=>`- ${t.info}`)).join("\n")}deleteAll(){this.testCases=[],this.dao.deleteAll()}}class g{_id=null;predefinedEnvs=[];_env=null;constructor({dao:t,rootStore:e}){this.dao=t,this.rootStore=e,this.init()}get env(){if(!this._env)throw new Error("No environment set");return this._env}init(){this.loadValues()}loadValues(){const t=this.dao.getAll()[0];if(!t){const t=s();return this._id=t,void this.dao.createOne({...this.asCopyData,id:t})}const{id:e,predefinedEnvs:i,env:n}=t;this._id=e,this.predefinedEnvs=i,this._env=n}get asCopyData(){return{predefinedEnvs:this.predefinedEnvs,env:this._env}}update({predefinedEnvs:t,env:e}){t&&(this.predefinedEnvs=t),void 0!==e&&(this._env=e),this._id&&this.dao.updateById(this._id,this.asCopyData)}setEnv(t){this.update({env:t})}setPredefinedEnvs(t){this.update({predefinedEnvs:t})}}const x=new r,p=new o,f=new a,y=new class{constructor({executionDao:t,testCaseDao:e,settingsDao:s}){this.executionStore=new l({dao:t,rootStore:this}),this.testCaseStore=new c({dao:e,rootStore:this}),this.settings=new g({dao:s,rootStore:this})}}({executionDao:x,testCaseDao:p,settingsDao:f}),m=y.settings,I=y.testCaseStore,C=e=>{const s=(t=>{const e={};return e[t.variableName]=t,e})(e);t(window,s)};t(window,{setAvailableEnvironments:t=>m.setPredefinedEnvs(t),setEnvironment:t=>m.setEnv(t),createCase:t=>{const e=I.create({id:t,executions:{}});return C(e),e.info},createCases:(t,e=!1)=>{const s=I.createMany(t.map((t=>({id:t,executions:{}}))));e&&s.forEach((t=>C(t)))},importCases:t=>I.import(t),getCases:()=>I.testCases,listCases:(t,s)=>e((()=>I.list(s)),t),listCasesDone:t=>e((()=>I.listExecuted()),t),listCasesNotRun:t=>e((()=>I.listNotRun()),t),listPassedCases:t=>e((()=>I.listByResult("passed")),t),listFailedCases:t=>e((()=>I.listByResult("failed")),t),listBlockedCases:t=>e((()=>I.listByResult("blocked")),t),getTestReport:(t,s)=>e((()=>I.getReport(t)),s),getRandomCaseNotRun:()=>{const t=I.getRandomNotRun();return t?(C(t),t.info):console.log("Empty not-run test case list")},getCaseById(t){const e=I.getOneById(t);return e?(C(e),e.info):console.log("not found")}})}main();